// Наследование

// Наследование является одним из ключевых моментов объектно-ориентированного
// программирования, позволяя передавать одним классам функционал других.
// В языке Dart наследование реализуется с помощью ключевого слова extends
//(как в Java):

import 'dart:ffi';

void main(List<String> arguments) {
  // ignore: omit_local_variable_types
  Employee bob = Employee();
  // Класс Employee, который представляет работника, является подклассом или наследуется
  // от класса Person. А класс Person называется родительским или базовым классом.
  // При наследовании класс Employee перенимает весь функционал класса Person - все его
  // поля и методы и может их использовать. И также можно определить в подклассе новые
  // поля и методы, которых нет в классе Person.

  // В итоге мы можем создать объект Employee и обращаться к его полю name
  // и методу display, хотя они определены в родительском классе Person.
  bob.name = 'Bob';
  bob.display();

  // Переопределение
  // ignore: omit_local_variable_types
  Employee me = Employee.company(name: 'Вазген', company: 'PROWEB');
  me.display();
  me.displayC();

  // Figure ellipse = Figure();   // так сделать нельзя - класс Figure - абстрактный

  // Классная работа
  Transport tayota =
      Car(name: 'Тайота камри', power: 78000, doors: 2, transmission: true);
  print(tayota);

  Transport bike = Motorbike(name: 'Yamaha', power: 444);

  print(bike);
}

class Person {
  String name = '';

  Person(this.name);

  void display() {
    print('Name: $name\n');
  }

  void displayC() {
    print('Name: $name');
  }
}

class Employee extends Person {
  late String company;

  // Конструкторы и ключевое слово super В отличие от полей и методов конструкторы
  // базового класса не наследуются.

  // Если базовый класс явным образом определяет конструктор (конструктор по умолчанию
  // не учитывается), то его необходимо вызвать в классе-наследнике при определении
  // конструктора:
  Employee() : super('');
  Employee.forName(String name) : super(name);
  Employee.company({required String name, required this.company}) : super(name);
  // Если мы не вызовем конструктор базового класса при определении конструктора в
  // производном классе, то мы столкнемся с ошибкой.

  // Переопределение методов
  // Производные классы могут определять свои поля и методы, но также могут переопределять,
  // изменять поведение методов базового класса.
  // Для этого применяется аннотация @override:

  // Здесь в класс Employee добавляется еще одно поле - company для хранения места
  // работы сотрудника. Чтобы эту информацию вывести на консоль, переопределяется метод display.
  @override
  void displayC() {
    super.displayC();
    print('Компания: $company\n');
    // Однако мы видим, что часть кода метода display в Employee повторяет
    // код метода display из Person. Чтобы не повторяться, с помощью ключевого слова
    // super мы можем просто вызвать реализацию метода display из базового класса:
  }
}

// Абстрактные классы представляют классы, определенные с ключевым словом abstract:

abstract class Figure {
  // Абстрактные классы похожи на обычные классы (также могут определять поля,
  // методы, конструкторы) за тем исключением, что мы не можем создать напрямую
  // объект абстрактного класса, используя его конструктор.
  // void calculateArea() {
  //   print('Not Implemented');
  // }
  // Абстрактные методы
  // В примере выше метод calculateArea в базовом классе Figure не выполняет никакой
  // полезной работы, так как у абстрактной фигуры не может быть площади. И в этом случае
  // подобный метод лучше определить как абстрактный:
  void calculateArea();
}

class Rectangle extends Figure {
  int width;
  int height;
  Rectangle(this.width, this.height);

  @override
  void calculateArea() {
    // ignore: omit_local_variable_types
    int area = width * height;
    print('area = $area');
  }

  // Важно отметить, что абстрактные методы могут быть определены только в абстрактных
  // классах. Кроме того, если базовый класс определяет абстрактный метод, то
  // класс-наследник обязательно должен его реализовать, то есть определить тело метода.
}

// Реализация интерфейсов
// Наследование в языке Dart имеет важное ограничение: мы не можем наследовать класс сразу
// от нескольких классов, например, следующим образом:

class Worker {
  String company = '';
  void work() {
    print('Work in $company');
  }
}

// class Student extends Person, Worker{ // Ошибка, множественное наследование не допускается
// }

// Для решения этой проблемы в Dart применяется реализация интерфейсов. При этом важно
// понимать, что интерфейс - это не отдельная сущность, как в некоторых языках
// программирования (например, тип interface в C# или Java), а тот же класс. То есть класс
// в Dart одновременно выступает в роли интерфейса, и другой класс может реализовать данный
// интерфейс.

// Интерфейс представляет синтаксический контракт, которому должны следовать реализующие
// этот интерфейс классы. То есть, если класс-интерфейс определяет какие-нибудь поля и
// методы, то класс, реализующий данный интерфейс, должен также определить эти поля и
// методы.

class Student implements Person {
  @override
  String name = ''; // реализация поля name
  // реализация метода display
  @override
  void display() {
    print('Employee name: $name');
  }

  @override
  void displayC() {
    print('Employee name: $name');
  }
}

// Наследование классов vs реализация интерфейсов

// При наследовании производный класс не обязан определять те же поля и методы, которые
// есть в базовом классе (за исключением абстрактных методов). Если базовом классе
// определяется конструктор, то производный класс обязан определить свой конструктор,
// при котором вызывается конструктор базового класса. В производном классе мы можем
// обращаться к реализации базового класса с помощью ключевого слова super. Не поддерживается
// множественное наследование.

// При реализации интерфейса производный класс должен определить все поля и методы, которые
// определены в классе интерфейса. Если в базовом есть конструктор, то производный класс НЕ
// обязан определять свой конструктор. В производном классе мы НЕ можем обращаться к методам
// реализованного интерфейса с помощью ключевого слова super. Поддерживается множественная
// реализация интерфейсов.

// Классное задание
// Реализовать класс транспорта, с полями: название марки, количества колес, лошадиные силы
// автоматическая коробка передачь или нет(boolean), количество дверей, тип транспорта
// От него унаследовать 2 класса, автомобили, мотоциклы
// переопределить у них метод вывода всего в косоль

class Transport {
  String name; // Марка
  double horsepower; // лошадиные силы
  String type = '';
  Transport({
    required this.name,
    required this.horsepower,
  });

  @override
  String toString() {
    var str =
        'Тип транспорта: $type\nМарка: $name\nКоличество лошадинные силы: $horsepower\n';
    return str;
  }
}

class Car extends Transport {
  int wheels = 4;
  @override
  String type = 'Машина';
  int doors;
  bool transmission;

  Car({
    required name,
    required double power,
    this.doors = 4,
    this.transmission = false,
  }) : super(name: name, horsepower: power);

  @override
  String toString() {
    return super.toString() +
        'Дверей: ${doors <= 0 ? 'нет' : doors}\nКоробка передачь: ${transmission ? 'автомат' : 'механника'}\nКоличество колёс: $wheels\n';
  }
}

class Motorbike extends Car {
  @override
  int wheels = 2;
  @override
  String type = 'Мотоцикл';

  Motorbike({
    required name,
    required double power,
  }) : super(name: name, transmission: true, doors: 0, power: power);
}
